import pyzed.sl as sl
import cv2
import math
import numpy as np

# Initialize ZED 2i Camera
zed = sl.Camera()

init_params = sl.InitParameters()
init_params.camera_resolution = sl.RESOLUTION.HD720  # Set resolution to HD720
init_params.depth_mode = sl.DEPTH_MODE.PERFORMANCE  # Best depth accuracy
init_params.coordinate_units = sl.UNIT.METER  # Use meters
init_params.camera_fps = 60  # Ensure smooth frame rate at 60 FPS
init_params.depth_maximum_distance = 10  # Limit depth range
init_params.depth_stabilization = 10  # Enable stabilization
init_params.enable_image_enhancement = True  # Improve clarity

if zed.open(init_params) != sl.ERROR_CODE.SUCCESS:
    print("Failed to open ZED 2i camera")
    exit()

# Enable Positional Tracking for improved depth accuracy
tracking_params = sl.PositionalTrackingParameters()
tracking_params.enable_area_memory = True
zed.enable_positional_tracking(tracking_params)

# Setup runtime parameters
runtime_parameters = sl.RuntimeParameters()

# Create image and depth containers
image_left = sl.Mat()
point_cloud = sl.Mat()
clicked_points = []
mouse_x, mouse_y = 0, 0  # Store mouse position
measured_distance = None
last_feedback = ""  # Stores user feedback messages

# Define depth validity range
MIN_DEPTH = 0.2  # 20 cm
MAX_DEPTH = 10.0  # 10 meters

# Function to capture 3D coordinates on mouse click
def get_3d_point(event, x, y, flags, param):
    global clicked_points, mouse_x, mouse_y, measured_distance, last_feedback
    if event == cv2.EVENT_MOUSEMOVE:
        mouse_x, mouse_y = x, y  # Update mouse position

    if event == cv2.EVENT_LBUTTONDOWN:
        err_code, point = point_cloud.get_value(x, y)  # Get 3D point data
        
        if err_code == sl.ERROR_CODE.SUCCESS and len(point) >= 3:
            x3D, y3D, z3D = point[:3]  # Extract the 3D coordinates
            
            if validate_depth_data(point_cloud, x, y):
                clicked_points.append((x, y, x3D, y3D, z3D))
                last_feedback = "✅ Point selected!"
                print(f"Point ({x}, {y}): X={x3D:.3f}, Y={y3D:.3f}, Z={z3D:.3f} meters")

                if len(clicked_points) == 2:
                    p1, p2 = clicked_points
                    measured_distance = abs(p2[2] - p1[2])  # Measure along width (X-axis)
                    last_feedback = f"📏 Measured Width: {measured_distance * 100:.2f} cm"
                    print(last_feedback)
                    clicked_points.clear()

# Validate depth data
def validate_depth_data(depth_data, x, y):
    err_code, point = depth_data.get_value(x, y)
    if err_code == sl.ERROR_CODE.SUCCESS and len(point) >= 3:
        x3D, y3D, z3D = point[:3]
        if not any(math.isnan(v) or math.isinf(v) for v in (x3D, y3D, z3D)):
            if MIN_DEPTH <= z3D <= MAX_DEPTH:
                return True
    return False

# Depth smoothing function (extract only Z values)
def smooth_depth_map(depth_map):
    depth_values = depth_map[:, :, 2]  # Extract only Z-values
    depth_values[np.isnan(depth_values) | np.isinf(depth_values)] = 0  # Replace invalid values
    smoothed_depth = cv2.GaussianBlur(depth_values, (5, 5), 0)
    return smoothed_depth

cv2.namedWindow("ZED 2i Camera View")
cv2.setMouseCallback("ZED 2i Camera View", get_3d_point)

# Main loop
while True:
    if zed.grab(runtime_parameters) == sl.ERROR_CODE.SUCCESS:
        zed.retrieve_image(image_left, sl.VIEW.LEFT)  
        zed.retrieve_measure(point_cloud, sl.MEASURE.XYZRGBA)  

        img = np.copy(image_left.get_data())
        depth_data = point_cloud.get_data()
        smoothed_depth = smooth_depth_map(depth_data)

        crosshair_color = (0, 255, 0) if validate_depth_data(point_cloud, mouse_x, mouse_y) else (0, 0, 255)
        cv2.drawMarker(img, (mouse_x, mouse_y), crosshair_color, cv2.MARKER_CROSS, 15, 2)

        for i, (u, v, _, _, _) in enumerate(clicked_points):
            color = (0, 255, 0) if i == 0 else (0, 0, 255)
            cv2.circle(img, (u, v), 8, color, -1)
            cv2.putText(img, f"P{i+1}", (u + 10, v - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.7, color, 2)

        overlay = img.copy()
        alpha = 0.6
        cv2.rectangle(overlay, (10, 30), (img.shape[1]-10, 150), (0, 0, 0), -1)
        cv2.addWeighted(overlay, alpha, img, 1 - alpha, 0, img)

        cv2.putText(img, "Click two points to measure width", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
        if measured_distance is not None:
            cv2.putText(img, f"Width: {measured_distance * 100:.2f} cm", (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)
        if last_feedback:
            cv2.putText(img, last_feedback, (10, 90), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 200, 200), 2)
        cv2.putText(img, f"Mouse Position: X={mouse_x}, Y={mouse_y}", (10, 120), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (200, 200, 0), 2)

        cv2.imshow("ZED 2i Camera View", img)

    key = cv2.waitKey(1) & 0xFF
    if key == ord('q'):
        break
    elif key == ord('r'):
        clicked_points.clear()
        measured_distance = None
        last_feedback = "🔄 Reset points!"

cv2.destroyAllWindows()
zed.close()

// el code da akher code we shaghal error 2cm
