import pyzed.sl as sl
import cv2
import math
import numpy as np

# Initialize ZED 2i Camera
zed = sl.Camera()

init_params = sl.InitParameters()
init_params.camera_resolution = sl.RESOLUTION.HD720  # Set resolution to HD720
init_params.depth_mode = sl.DEPTH_MODE.PERFORMANCE  # Best depth accuracy
init_params.coordinate_units = sl.UNIT.METER  # Use meters
init_params.camera_fps = 60  # Ensure smooth frame rate at 60 FPS
init_params.depth_maximum_distance = 10  # Limit depth range
init_params.depth_stabilization = 10  # Enable stabilization
init_params.enable_image_enhancement = True  # Improve clarity

if zed.open(init_params) != sl.ERROR_CODE.SUCCESS:
    print("Failed to open ZED 2i camera")
    exit()

# Enable Positional Tracking for improved depth accuracy
tracking_params = sl.PositionalTrackingParameters()
tracking_params.enable_area_memory = True
zed.enable_positional_tracking(tracking_params)

# Setup runtime parameters
runtime_parameters = sl.RuntimeParameters()

# Create image and depth containers
image_left = sl.Mat()
point_cloud = sl.Mat()
clicked_points = []
mouse_x, mouse_y = 0, 0  # Store mouse position
measured_distance = None
last_feedback = ""  # Stores user feedback messages

# Function to capture 3D coordinates on mouse click
def get_3d_point(event, x, y, flags, param):
    global clicked_points, mouse_x, mouse_y, measured_distance, last_feedback
    if event == cv2.EVENT_MOUSEMOVE:
        mouse_x, mouse_y = x, y  # Update mouse position

    if event == cv2.EVENT_LBUTTONDOWN:
        err_code, point = point_cloud.get_value(x, y)  # Get 3D point data
        
        if err_code == sl.ERROR_CODE.SUCCESS and len(point) >= 3:
            x3D, y3D, z3D = point[:3]  # Extract the 3D coordinates
            
            # Check if the depth values are valid (not NaN or infinity)
            if not any(math.isnan(v) or math.isinf(v) for v in (x3D, y3D, z3D)):
                clicked_points.append((x, y, x3D, y3D, z3D))
                last_feedback = "‚úÖ Point selected!"
                print(f"Point ({x}, {y}): X={x3D:.3f}, Y={y3D:.3f}, Z={z3D:.3f} meters")

                if len(clicked_points) == 2:
                    p1, p2 = clicked_points
                    # Compute Euclidean distance
                    measured_distance = math.sqrt((p2[2] - p1[2]) ** 2 +
                                                  (p2[3] - p1[3]) ** 2 +
                                                  (p2[4] - p1[4]) ** 2)

                    last_feedback = f"üìè Measured Length: {measured_distance:.3f} meters"
                    print(last_feedback)

                    # Auto-reset after measurement
                    clicked_points.clear()
            else:
                last_feedback = "‚ùå Invalid depth data, try another point!"
                print(last_feedback)

# Apply smoothing to depth map to reduce noise
def smooth_depth_map(depth_map):
    # Apply a Gaussian filter to smooth the depth map
    smoothed_depth = cv2.GaussianBlur(depth_map, (5, 5), 0)
    return smoothed_depth

cv2.namedWindow("ZED 2i Camera View")
cv2.setMouseCallback("ZED 2i Camera View", get_3d_point)

# Main loop
while True:
    if zed.grab(runtime_parameters) == sl.ERROR_CODE.SUCCESS:
        # Retrieve left RGB image
        zed.retrieve_image(image_left, sl.VIEW.LEFT)  
        zed.retrieve_measure(point_cloud, sl.MEASURE.XYZRGBA)  # Use XYZRGBA for full 3D data

        # Convert image to OpenCV format
        img = image_left.get_data()
        img = np.copy(img)  # Ensure it's mutable

        # Smooth the depth map to reduce noise
        depth_data = point_cloud.get_data()
        smoothed_depth = smooth_depth_map(depth_data)

        # Draw crosshair at mouse position (red if depth is invalid)
        err_code, point = point_cloud.get_value(mouse_x, mouse_y)
        crosshair_color = (0, 255, 0) if err_code == sl.ERROR_CODE.SUCCESS else (0, 0, 255)
        cv2.drawMarker(img, (mouse_x, mouse_y), crosshair_color, cv2.MARKER_CROSS, 15, 2)

        # Draw clicked points as labeled circles
        for i, (u, v, _, _, _) in enumerate(clicked_points):
            color = (0, 255, 0) if i == 0 else (0, 0, 255)  # First point: green, Second: red
            cv2.circle(img, (u, v), 8, color, -1)
            cv2.putText(img, f"P{i+1}", (u + 10, v - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.7, color, 2)

        # Add a translucent background for the status messages
        overlay = img.copy()
        alpha = 0.6
        cv2.rectangle(overlay, (10, 30), (img.shape[1]-10, 150), (0, 0, 0), -1)
        cv2.addWeighted(overlay, alpha, img, 1 - alpha, 0, img)

        # Display instructions and status messages
        cv2.putText(img, "Click two points to measure distance", (10, 30),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)

        if measured_distance is not None:
            cv2.putText(img, f"Distance: {measured_distance:.3f}m", (10, 60),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)

        # Show last feedback message (valid/invalid selection)
        if last_feedback:
            cv2.putText(img, last_feedback, (10, 90),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 200, 200), 2)

        # Display mouse 3D position in status area
        cv2.putText(img, f"Mouse 3D Position: X={mouse_x} Y={mouse_y}", (10, 120),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (200, 200, 0), 2)

        cv2.imshow("ZED 2i Camera View", img)

    # Keyboard shortcuts
    key = cv2.waitKey(1) & 0xFF
    if key == ord('q'):  # Quit
        break
    elif key == ord('r'):  # Reset points manually
        clicked_points.clear()
        measured_distance = None
        last_feedback = "üîÑ Reset points!"

cv2.destroyAllWindows()
zed.close()
